#include "MetalScrollPCH.h"

// generated by: http://code.google.com/p/gen-is-keyword-fn/
bool IsUscriptKeyword(const wchar_t* c, unsigned int l)
{
 switch(l){
 case 2:
   switch(c[0]){
   case 'D':
   case 'd':
    // Do
    return c[1]=='o' || c[1]=='O';
   case 'I':
   case 'i':
    // If
    return c[1]=='f' || c[1]=='F';
   }
 case 3:
   switch(c[0]){
   case 'E':
   case 'e':
    // End
    return _wcsnicmp(c+1, L"nd", 2)==0;
   case 'F':
   case 'f':
    // For
    return _wcsnicmp(c+1, L"or", 2)==0;
   case 'I':
   case 'i':
    // Int
    return _wcsnicmp(c+1, L"nt", 2)==0;
   case 'M':
   case 'm':
    // Map
    return _wcsnicmp(c+1, L"ap", 2)==0;
   case 'N':
   case 'n':
    // New
    return _wcsnicmp(c+1, L"ew", 2)==0;
   case 'O':
   case 'o':
    // Out
    return _wcsnicmp(c+1, L"ut", 2)==0;
   case 'R':
   case 'r':
    switch(c[1]){
    case 'n':
    case 'N':
     // Rng
     return c[2]=='g' || c[2]=='G';
    case 'o':
    case 'O':
     // Rot
     return c[2]=='t' || c[2]=='T';
    }
    break;
   case 'V':
   case 'v':
    // Var
    return _wcsnicmp(c+1, L"ar", 2)==0;
   }
 case 4:
   switch(c[0]){
   case 'A':
   case 'a':
    // Auto
    return _wcsnicmp(c+1, L"uto", 3)==0;
   case 'B':
   case 'b':
    switch(c[1]){
    case 'o':
    case 'O':
     // Bool
     return _wcsnicmp(c+2, L"ol", 2)==0;
    case 'y':
    case 'Y':
     // Byte
     return _wcsnicmp(c+2, L"te", 2)==0;
    }
    break;
   case 'C':
   case 'c':
    // Case
    return _wcsnicmp(c+1, L"ase", 3)==0;
   case 'E':
   case 'e':
    switch(c[1]){
    case 'l':
    case 'L':
     // Else
     return _wcsnicmp(c+2, L"se", 2)==0;
    case 'n':
    case 'N':
     // Enum
     return _wcsnicmp(c+2, L"um", 2)==0;
    case 'x':
    case 'X':
     // Exec
     return _wcsnicmp(c+2, L"ec", 2)==0;
    }
    break;
   case 'F':
   case 'f':
    // From
    return _wcsnicmp(c+1, L"rom", 3)==0;
   case 'G':
   case 'g':
    switch(c[1]){
    case 'o':
    case 'O':
     // Goto
     return _wcsnicmp(c+2, L"to", 2)==0;
    case 'u':
    case 'U':
     // Guid
     return _wcsnicmp(c+2, L"id", 2)==0;
    }
    break;
   case 'N':
   case 'n':
    switch(c[1]){
    case 'a':
    case 'A':
     // Name
     return _wcsnicmp(c+2, L"me", 2)==0;
    case 'o':
    case 'O':
     // None
     return _wcsnicmp(c+2, L"ne", 2)==0;
    }
    break;
   case 'Q':
   case 'q':
    // Quat
    return _wcsnicmp(c+1, L"uat", 3)==0;
   case 'S':
   case 's':
    switch(c[1]){
    case 'e':
    case 'E':
     // Self
     return _wcsnicmp(c+2, L"lf", 2)==0;
    case 'k':
    case 'K':
     // Skip
     return _wcsnicmp(c+2, L"ip", 2)==0;
    case 't':
    case 'T':
     // Stop
     return _wcsnicmp(c+2, L"op", 2)==0;
    }
    break;
   case 'T':
   case 't':
    // TRUE
    return _wcsnicmp(c+1, L"RUE", 3)==0;
   case 'V':
   case 'v':
    // Vect
    return _wcsnicmp(c+1, L"ect", 3)==0;
   }
 case 5:
   switch(c[0]){
   case 'A':
   case 'a':
    // Array
    return _wcsnicmp(c+1, L"rray", 4)==0;
   case 'B':
   case 'b':
    switch(c[1]){
    case 'e':
    case 'E':
     // Begin
     return _wcsnicmp(c+2, L"gin", 3)==0;
    case 'r':
    case 'R':
     // Break
     return _wcsnicmp(c+2, L"eak", 3)==0;
    }
    break;
   case 'C':
   case 'c':
    switch(c[2]){
    case 'a':
    case 'A':
     // Class
     return _wcsnicmp(c+1, L"lass", 4)==0;
    case 'l':
    case 'L':
     // Color
     return _wcsnicmp(c+1, L"olor", 4)==0;
    case 'n':
    case 'N':
     // Const
     return _wcsnicmp(c+1, L"onst", 4)==0;
    }
    break;
   case 'E':
   case 'e':
    // Event
    return _wcsnicmp(c+1, L"vent", 4)==0;
   case 'F':
   case 'f':
    switch(c[1]){
    case 'A':
    case 'a':
     // FALSE
     return _wcsnicmp(c+2, L"LSE", 3)==0;
    case 'i':
    case 'I':
     // Final
     return _wcsnicmp(c+2, L"nal", 3)==0;
    case 'l':
    case 'L':
     // Float
     return _wcsnicmp(c+2, L"oat", 3)==0;
    }
    break;
   case 'I':
   case 'i':
    // Input
    return _wcsnicmp(c+1, L"nput", 4)==0;
   case 'L':
   case 'l':
    // Local
    return _wcsnicmp(c+1, L"ocal", 4)==0;
   case 'O':
   case 'o':
    // Outer
    return _wcsnicmp(c+1, L"uter", 4)==0;
   case 'P':
   case 'p':
    // Plane
    return _wcsnicmp(c+1, L"lane", 4)==0;
   case 'Q':
   case 'q':
    // QWord
    return _wcsnicmp(c+1, L"Word", 4)==0;
   case 'S':
   case 's':
    switch(c[1]){
    case 'p':
    case 'P':
     // Spawn
     return _wcsnicmp(c+2, L"awn", 3)==0;
    case 't':
    case 'T':
     // State
     return _wcsnicmp(c+2, L"ate", 3)==0;
    case 'u':
    case 'U':
     // Super
     return _wcsnicmp(c+2, L"per", 3)==0;
    }
    break;
   case 'U':
   case 'u':
    // Until
    return _wcsnicmp(c+1, L"ntil", 4)==0;
   case 'W':
   case 'w':
    // While
    return _wcsnicmp(c+1, L"hile", 4)==0;
   }
 case 6:
   switch(c[0]){
   case 'A':
   case 'a':
    switch(c[1]){
    case 'l':
    case 'L':
     // Always
     return _wcsnicmp(c+2, L"ways", 4)==0;
    case 's':
    case 'S':
     // Assert
     return _wcsnicmp(c+2, L"sert", 4)==0;
    case 't':
    case 'T':
     // Atomic
     return _wcsnicmp(c+2, L"omic", 4)==0;
    }
    break;
   case 'B':
   case 'b':
    // Button
    return _wcsnicmp(c+1, L"utton", 5)==0;
   case 'C':
   case 'c':
    switch(c[2]){
    case 'i':
    case 'I':
     // Client
     return _wcsnicmp(c+1, L"lient", 5)==0;
    case 'e':
    case 'E':
     // Coerce
     return _wcsnicmp(c+1, L"oerce", 5)==0;
    case 'n':
    case 'N':
     // Config
     return _wcsnicmp(c+1, L"onfig", 5)==0;
    }
    break;
   case 'D':
   case 'd':
    // Double
    return _wcsnicmp(c+1, L"ouble", 5)==0;
   case 'E':
   case 'e':
    switch(c[1]){
    case 'l':
    case 'L':
     // ElseIf
     return _wcsnicmp(c+2, L"seIf", 4)==0;
    case 'x':
    case 'X':
     // Export
     return _wcsnicmp(c+2, L"port", 4)==0;
    }
    break;
   case 'G':
   case 'g':
    // Global
    return _wcsnicmp(c+1, L"lobal", 5)==0;
   case 'I':
   case 'i':
    switch(c[1]){
    case 'm':
    case 'M':
     // Import
     return _wcsnicmp(c+2, L"port", 4)==0;
    case 'n':
    case 'N':
     // Interp
     return _wcsnicmp(c+2, L"terp", 4)==0;
    }
    break;
   case 'L':
   case 'l':
    // Latent
    return _wcsnicmp(c+1, L"atent", 5)==0;
   case 'M':
   case 'm':
    // Matrix
    return _wcsnicmp(c+1, L"atrix", 5)==0;
   case 'N':
   case 'n':
    switch(c[2]){
    case 'm':
    case 'M':
     // NameOf
     return _wcsnicmp(c+1, L"ameOf", 5)==0;
    case 't':
    case 'T':
     // Native
     return _wcsnicmp(c+1, L"ative", 5)==0;
    }
    break;
   case 'O':
   case 'o':
    // Object
    return _wcsnicmp(c+1, L"bject", 5)==0;
   case 'P':
   case 'p':
    switch(c[1]){
    case 'a':
    case 'A':
     // Parent
     return _wcsnicmp(c+2, L"rent", 4)==0;
    case 'u':
    case 'U':
     // Public
     return _wcsnicmp(c+2, L"blic", 4)==0;
    }
    break;
   case 'R':
   case 'r':
    // Return
    return _wcsnicmp(c+1, L"eturn", 5)==0;
   case 'S':
   case 's':
    switch(c[5]){
    case 'r':
    case 'R':
     // Server
     return _wcsnicmp(c+1, L"erver", 5)==0;
    case 'c':
    case 'C':
     // Static
     return _wcsnicmp(c+1, L"tatic", 5)==0;
    case 'g':
    case 'G':
     // String
     return _wcsnicmp(c+1, L"tring", 5)==0;
    case 't':
    case 'T':
     // Struct
     return _wcsnicmp(c+1, L"truct", 5)==0;
    case 'h':
    case 'H':
     // Switch
     return _wcsnicmp(c+1, L"witch", 5)==0;
    }
    break;
   case 'V':
   case 'v':
    // Vector
    return _wcsnicmp(c+1, L"ector", 5)==0;
   case 'W':
   case 'w':
    // Within
    return _wcsnicmp(c+1, L"ithin", 5)==0;
   }
 case 7:
   switch(c[2]){
   case 'f':
   case 'F':
    // Default
    return _wcsnicmp(c, L"Default", 7)==0;
   case 't':
   case 'T':
    switch(c[0]){
    case 'E':
    case 'e':
     // Extends
     return _wcsnicmp(c+1, L"xtends", 6)==0;
    case 'R':
    case 'r':
     // Rotator
     return _wcsnicmp(c+1, L"otator", 6)==0;
    }
    break;
   case 'r':
   case 'R':
    switch(c[0]){
    case 'F':
    case 'f':
     // ForEach
     return _wcsnicmp(c+1, L"orEach", 6)==0;
    case 'V':
    case 'v':
     // Virtual
     return _wcsnicmp(c+1, L"irtual", 6)==0;
    }
    break;
   case 'n':
   case 'N':
    // Ignores
    return _wcsnicmp(c, L"Ignores", 7)==0;
   case 'C':
   case 'c':
    // NoClear
    return _wcsnicmp(c, L"NoClear", 7)==0;
   case 'i':
   case 'I':
    switch(c[1]){
    case 'o':
    case 'O':
     // Pointer
     return _wcsnicmp(c, L"Pointer", 7)==0;
    case 'r':
    case 'R':
     // Private
     return _wcsnicmp(c, L"Private", 7)==0;
    }
    break;
   }
 case 8:
   switch(c[0]){
   case 'A':
   case 'a':
    // Abstract
    return _wcsnicmp(c+1, L"bstract", 7)==0;
   case 'C':
   case 'c':
    // Continue
    return _wcsnicmp(c+1, L"ontinue", 7)==0;
   case 'D':
   case 'd':
    // Delegate
    return _wcsnicmp(c+1, L"elegate", 7)==0;
   case 'E':
   case 'e':
    // EditHide
    return _wcsnicmp(c+1, L"ditHide", 7)==0;
   case 'F':
   case 'f':
    // Function
    return _wcsnicmp(c+1, L"unction", 7)==0;
   case 'I':
   case 'i':
    switch(c[1]){
    case 'n':
    case 'N':
     // Inherits
     return _wcsnicmp(c+2, L"herits", 6)==0;
    case 't':
    case 'T':
     // Iterator
     return _wcsnicmp(c+2, L"erator", 6)==0;
    }
    break;
   case 'N':
   case 'n':
    switch(c[2]){
    case 'E':
    case 'e':
     // NoExport
     return _wcsnicmp(c+1, L"oExport", 7)==0;
    case 'I':
    case 'i':
     // NoImport
     return _wcsnicmp(c+1, L"oImport", 7)==0;
    }
    break;
   case 'O':
   case 'o':
    switch(c[2]){
    case 'e':
    case 'E':
     // Operator
     return _wcsnicmp(c+1, L"perator", 7)==0;
    case 't':
    case 'T':
     // Optional
     return _wcsnicmp(c+1, L"ptional", 7)==0;
    }
    break;
   case 'R':
   case 'r':
    switch(c[2]){
    case 'l':
    case 'L':
     // Reliable
     return _wcsnicmp(c+1, L"eliable", 7)==0;
    case 'p':
    case 'P':
     // RepRetry
     return _wcsnicmp(c+1, L"epRetry", 7)==0;
    }
    break;
   case 'S':
   case 's':
    switch(c[1]){
    case 'H':
    case 'h':
     // SHVector
     return _wcsnicmp(c+2, L"Vector", 6)==0;
    case 'i':
    case 'I':
     // Singular
     return _wcsnicmp(c+2, L"ngular", 6)==0;
    }
    break;
   }
 case 9:
   switch(c[2]){
   case 'c':
   case 'C':
    switch(c[0]){
    case 'A':
    case 'a':
     // Archetype
     return _wcsnicmp(c+1, L"rchetype", 8)==0;
    case 'L':
    case 'l':
     // Localized
     return _wcsnicmp(c+1, L"ocalized", 8)==0;
    }
    break;
   case 't':
   case 'T':
    switch(c[3]){
    case 'o':
    case 'O':
     // Automated
     return _wcsnicmp(c, L"Automated", 9)==0;
    case 'e':
    case 'E':
     // Interface
     return _wcsnicmp(c, L"Interface", 9)==0;
    case 'r':
    case 'R':
     // Intrinsic
     return _wcsnicmp(c, L"Intrinsic", 9)==0;
    }
    break;
   case 'L':
   case 'l':
    // DLLImport
    return _wcsnicmp(c, L"DLLImport", 9)==0;
   case 'p':
   case 'P':
    switch(c[0]){
    case 'D':
    case 'd':
     // DependsOn
     return _wcsnicmp(c+1, L"ependsOn", 8)==0;
    case 'R':
    case 'r':
     // RepNotify
     return _wcsnicmp(c+1, L"epNotify", 8)==0;
    }
    break;
   case 'i':
   case 'I':
    // EditConst
    return _wcsnicmp(c, L"EditConst", 9)==0;
   case 'u':
   case 'U':
    // EnumCount
    return _wcsnicmp(c, L"EnumCount", 9)==0;
   case 'm':
   case 'M':
    switch(c[0]){
    case 'I':
    case 'i':
     // Immutable
     return _wcsnicmp(c+1, L"mmutable", 8)==0;
    case 'S':
    case 's':
     // Simulated
     return _wcsnicmp(c+1, L"imulated", 8)==0;
    }
    break;
   case 's':
   case 'S':
    // Instanced
    return _wcsnicmp(c, L"Instanced", 9)==0;
   case 'v':
   case 'V':
    // Invariant
    return _wcsnicmp(c, L"Invariant", 9)==0;
   case 'a':
   case 'A':
    switch(c[0]){
    case 'P':
    case 'p':
     // Placeable
     return _wcsnicmp(c+1, L"laceable", 8)==0;
    case 'T':
    case 't':
     // Transient
     return _wcsnicmp(c+1, L"ransient", 8)==0;
    }
    break;
   case 'o':
   case 'O':
    // Protected
    return _wcsnicmp(c, L"Protected", 9)==0;
   }
 case 10:
   switch(c[5]){
   case 'C':
   case 'c':
    // ArrayCount
    return _wcsnicmp(c, L"ArrayCount", 10)==0;
   case 'G':
   case 'g':
    // ClassGroup
    return _wcsnicmp(c, L"ClassGroup", 10)==0;
   case 'L':
   case 'l':
    // CrossLevel
    return _wcsnicmp(c, L"CrossLevel", 10)==0;
   case 'n':
   case 'N':
    // EditInline
    return _wcsnicmp(c, L"EditInline", 10)==0;
   case 'r':
   case 'R':
    // EditorOnly
    return _wcsnicmp(c, L"EditorOnly", 10)==0;
   case 'm':
   case 'M':
    // Implements
    return _wcsnicmp(c, L"Implements", 10)==0;
   case 'e':
   case 'E':
    // NativeOnly
    return _wcsnicmp(c, L"NativeOnly", 10)==0;
   case 'i':
   case 'I':
    // Unreliable
    return _wcsnicmp(c, L"Unreliable", 10)==0;
   }
 case 11:
   switch(c[0]){
   case 'E':
   case 'e':
    // EditTextBox
    return _wcsnicmp(c+1, L"ditTextBox", 10)==0;
   case 'L':
   case 'l':
    // LinearColor
    return _wcsnicmp(c+1, L"inearColor", 10)==0;
   case 'P':
   case 'p':
    // PreOperator
    return _wcsnicmp(c+1, L"reOperator", 10)==0;
   case 'R':
   case 'r':
    // Replication
    return _wcsnicmp(c+1, L"eplication", 10)==0;
   case 'S':
   case 's':
    // SafeReplace
    return _wcsnicmp(c+1, L"afeReplace", 10)==0;
   }
 case 12:
   switch(c[2]){
   case 'o':
   case 'O':
    // GlobalConfig
    return _wcsnicmp(c, L"GlobalConfig", 12)==0;
   case 'd':
   case 'D':
    // HideDropDown
    return _wcsnicmp(c, L"HideDropDown", 12)==0;
   case 'n':
   case 'N':
    // NonTransient
    return _wcsnicmp(c, L"NonTransient", 12)==0;
   case 't':
   case 'T':
    // NotPlaceable
    return _wcsnicmp(c, L"NotPlaceable", 12)==0;
   case 's':
   case 'S':
    // PostOperator
    return _wcsnicmp(c, L"PostOperator", 12)==0;
   case 'i':
   case 'I':
    // PrivateWrite
    return _wcsnicmp(c, L"PrivateWrite", 12)==0;
   case 'r':
   case 'R':
    // StrictConfig
    return _wcsnicmp(c, L"StrictConfig", 12)==0;
   }
 case 13:
   switch(c[4]){
   case 'F':
   case 'f':
    // EditFixedSize
    return _wcsnicmp(c, L"EditFixedSize", 13)==0;
   case 'I':
   case 'i':
    switch(c[10]){
    case 'N':
    case 'n':
     // EditInlineNew
     return _wcsnicmp(c, L"EditInlineNew", 13)==0;
    case 'U':
    case 'u':
     // EditInlineUse
     return _wcsnicmp(c, L"EditInlineUse", 13)==0;
    }
    break;
   case 'o':
   case 'O':
    // NotForConsole
    return _wcsnicmp(c, L"NotForConsole", 13)==0;
   case 'a':
   case 'A':
    // SerializeText
    return _wcsnicmp(c, L"SerializeText", 13)==0;
   case 'c':
   case 'C':
    // structcpptext
    return _wcsnicmp(c, L"structcpptext", 13)==0;
   }
 case 14:
   switch(c[0]){
   case 'H':
   case 'h':
    // HideCategories
    return _wcsnicmp(c+1, L"ideCategories", 13)==0;
   case 'N':
   case 'n':
    // NoExportHeader
    return _wcsnicmp(c+1, L"oExportHeader", 13)==0;
   case 'P':
   case 'p':
    // ProtectedWrite
    return _wcsnicmp(c+1, L"rotectedWrite", 13)==0;
   case 'S':
   case 's':
    // ShowCategories
    return _wcsnicmp(c+1, L"howCategories", 13)==0;
   }
 case 15:
   // PerObjectConfig
   return _wcsnicmp(c, L"PerObjectConfig", 15)==0;
 case 16:
   switch(c[2]){
   case 'o':
   case 'O':
    // CrossLevelActive
    return _wcsnicmp(c, L"CrossLevelActive", 16)==0;
   case 'l':
   case 'L':
    // FilterEditorOnly
    return _wcsnicmp(c, L"FilterEditorOnly", 16)==0;
   case 'n':
   case 'N':
    // NonTransactional
    return _wcsnicmp(c, L"NonTransactional", 16)==0;
   case 't':
   case 'T':
    // NotEditInlineNew
    return _wcsnicmp(c, L"NotEditInlineNew", 16)==0;
   }
 case 17:
   switch(c[0]){
   case 'C':
   case 'c':
    // CrossLevelPassive
    return _wcsnicmp(c+1, L"rossLevelPassive", 16)==0;
   case 'N':
   case 'n':
    // NativeReplication
    return _wcsnicmp(c+1, L"ativeReplication", 16)==0;
   case 'd':
   case 'D':
    // defaultproperties
    return _wcsnicmp(c+1, L"efaultproperties", 16)==0;
   }
 case 18:
   switch(c[2]){
   case 'l':
   case 'L':
    // CollapseCategories
    return _wcsnicmp(c, L"CollapseCategories", 18)==0;
   case 'n':
   case 'N':
    // DontSortCategories
    return _wcsnicmp(c, L"DontSortCategories", 18)==0;
   case 'p':
   case 'P':
    // DuplicateTransient
    return _wcsnicmp(c, L"DuplicateTransient", 18)==0;
   case 'r':
   case 'R':
    // PerObjectLocalized
    return _wcsnicmp(c, L"PerObjectLocalized", 18)==0;
   }
 case 19:
   // ImmutableWhenCooked
   return _wcsnicmp(c, L"ImmutableWhenCooked", 19)==0;
 case 20:
   // AutoExpandCategories
   return _wcsnicmp(c, L"AutoExpandCategories", 20)==0;
 case 22:
   switch(c[0]){
   case 'A':
   case 'a':
    // AutoCollapseCategories
    return _wcsnicmp(c+1, L"utoCollapseCategories", 21)==0;
   case 'D':
   case 'd':
    // DontCollapseCategories
    return _wcsnicmp(c+1, L"ontCollapseCategories", 21)==0;
   }
 case 23:
   // structdefaultproperties
   return _wcsnicmp(c, L"structdefaultproperties", 23)==0;
 case 26:
   // DontAutoCollapseCategories
   return _wcsnicmp(c, L"DontAutoCollapseCategories", 26)==0;
 }
 return false;
}
